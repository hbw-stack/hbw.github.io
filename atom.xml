<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://blog.bangwhe.com</id>
    <title>日常 | Paper | 摸鱼</title>
    <updated>2021-05-24T09:55:24.851Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://blog.bangwhe.com"/>
    <link rel="self" href="https://blog.bangwhe.com/atom.xml"/>
    <subtitle>日常吐槽摸鱼日记，还有一些博客</subtitle>
    <logo>https://blog.bangwhe.com/images/avatar.png</logo>
    <icon>https://blog.bangwhe.com/favicon.ico</icon>
    <rights>All rights reserved 2021, 日常 | Paper | 摸鱼</rights>
    <entry>
        <title type="html"><![CDATA[PyQt5多线程]]></title>
        <id>https://blog.bangwhe.com/post/pyqt5-duo-xian-cheng/</id>
        <link href="https://blog.bangwhe.com/post/pyqt5-duo-xian-cheng/">
        </link>
        <updated>2021-05-23T13:17:23.000Z</updated>
        <summary type="html"><![CDATA[<p>主要是毕设的代码里要用到多线程，本来是想直接在函数里写个函数，然后直接用python的多线程库跑的，但是看到Qt也有多线程库QThread，于是就决定用它了。</p>
<p>如果只是简单的使用那就非常简单：</p>
<pre><code class="language-python">class Mythread(QThread):
    def __init__(self, **kwargs):
        super().__inint__()

    def run(self):
        do_something()
</code></pre>
<p>如果需要传参，可以在初始化时操作。如果需要使用qt的信号和槽机制，那就得加上qtsignal来传递数据（这好像是切换进程吧）。</p>
]]></summary>
        <content type="html"><![CDATA[<p>主要是毕设的代码里要用到多线程，本来是想直接在函数里写个函数，然后直接用python的多线程库跑的，但是看到Qt也有多线程库QThread，于是就决定用它了。</p>
<p>如果只是简单的使用那就非常简单：</p>
<pre><code class="language-python">class Mythread(QThread):
    def __init__(self, **kwargs):
        super().__inint__()

    def run(self):
        do_something()
</code></pre>
<p>如果需要传参，可以在初始化时操作。如果需要使用qt的信号和槽机制，那就得加上qtsignal来传递数据（这好像是切换进程吧）。</p>
<!-- more -->
<p>bug：我的bug其实挺简单的——线程被我设置成了局部变量，导致函数退出的时候线程变量被回收了，所以程序异常退出了，跟我之前那个程序的错误如出一辙。解决就是把线程变量设置为类变量，这样它就不会被回收了。</p>
<p>新bug：thread的事件绑定错误了，我在初始化的时候初始化了一个thread，但是进入的时候并不是这个thread（因为要修改一些入参），所以事件无法触发。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[2021-05-22]]></title>
        <id>https://blog.bangwhe.com/post/2021-05-22/</id>
        <link href="https://blog.bangwhe.com/post/2021-05-22/">
        </link>
        <updated>2021-05-22T16:38:39.000Z</updated>
        <summary type="html"><![CDATA[<p>打游戏：鲁班大师+姜子牙打弹弓非常快乐，打不打得到主要靠鲁班大师的瞄准，三点一线，然后姜子牙飞过来就可以打到人。</p>
<p>毕设论文：没怎么写，拖到周日再继续写吧。今天主要就是把环境配好了，然后运行了一遍test.py，成功了，明天迁移一下试试。</p>
<p>今天打了北京科兴的新冠疫苗，主要感受就是左手的针眼很凉，有一点点乏力。</p>
]]></summary>
        <content type="html"><![CDATA[<p>打游戏：鲁班大师+姜子牙打弹弓非常快乐，打不打得到主要靠鲁班大师的瞄准，三点一线，然后姜子牙飞过来就可以打到人。</p>
<p>毕设论文：没怎么写，拖到周日再继续写吧。今天主要就是把环境配好了，然后运行了一遍test.py，成功了，明天迁移一下试试。</p>
<p>今天打了北京科兴的新冠疫苗，主要感受就是左手的针眼很凉，有一点点乏力。</p>
<!-- more -->
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[git clone 提速]]></title>
        <id>https://blog.bangwhe.com/post/git-clone-ti-su/</id>
        <link href="https://blog.bangwhe.com/post/git-clone-ti-su/">
        </link>
        <updated>2021-05-22T07:31:07.000Z</updated>
        <summary type="html"><![CDATA[<p>主要参考链接：</p>
<ul>
<li>https://www.zhihu.com/question/27159393</li>
<li>https://blog.csdn.net/m0_37604813/article/details/107130881</li>
</ul>
<p>总结的主要方法：</p>
<ul>
<li>配置git proxy</li>
<li>走镜像（走码云再克隆也是一样的道理）</li>
<li>修改host文件</li>
<li><a href="https://greasyfork.org/zh-CN/scripts/412245-github-%E5%A2%9E%E5%BC%BA-%E9%AB%98%E9%80%9F%E4%B8%8B%E8%BD%BD">油猴脚本</a>，算是合集吧</li>
<li>对于git submodule而言，最直接的方法就是配置代理，如果想要走镜像，必须把所有路径下的.gitmodules文件修改，代码如下。</li>
</ul>
]]></summary>
        <content type="html"><![CDATA[<p>主要参考链接：</p>
<ul>
<li>https://www.zhihu.com/question/27159393</li>
<li>https://blog.csdn.net/m0_37604813/article/details/107130881</li>
</ul>
<p>总结的主要方法：</p>
<ul>
<li>配置git proxy</li>
<li>走镜像（走码云再克隆也是一样的道理）</li>
<li>修改host文件</li>
<li><a href="https://greasyfork.org/zh-CN/scripts/412245-github-%E5%A2%9E%E5%BC%BA-%E9%AB%98%E9%80%9F%E4%B8%8B%E8%BD%BD">油猴脚本</a>，算是合集吧</li>
<li>对于git submodule而言，最直接的方法就是配置代理，如果想要走镜像，必须把所有路径下的.gitmodules文件修改，代码如下。</li>
</ul>
<!-- more -->
<pre><code class="language-python">import os
import glob

import sys
import argparse


def parse_args():
    parser = argparse.ArgumentParser(description='修改gitmodules中的github链接为镜像链接')
    
    parser.add_argument('--root_dir', help='git项目的根目录', default='.')
    parser.add_argument('--mirror', help='镜像链接', choices=['github.com.cnpmjs.org', 'hub.fastgit.org'], default='github.com.cnpmjs.org')
    parser = parser.parse_args()
    
    return parser


def change_mirror_url(filename, mirror='github.com.cnpmjs.org', in_place=False):
    with open(filename) as f:
        lines = f.readlines()

    lines = [i.replace('github.com', mirror) for i in lines]
    
    if in_place:
        with open(filename, 'w') as f:
            for line in lines:
                f.write(line)
    
    return lines


if __name__ == '__main__':
    args = parse_args()
    root_dir = args.root_dir
    mirror = args.mirror
    assert '.git' in os.listdir(args.root_dir), '必须是git项目的根目录'

    files = glob.glob(f'{root_dir}/**/.gitmodules', recursive=True)
    for file in files:
        change_mirror_url(file, mirror=mirror, in_place=True)
        print(f'{file}修改完成...')
</code></pre>
<p>pytorch项目的输出：</p>
<pre><code class="language-log">.\pytorch\.gitmodules修改完成...
.\pytorch\third_party\fbgemm\.gitmodules修改完成...
.\pytorch\third_party\gloo\.gitmodules修改完成...
.\pytorch\third_party\ideep\.gitmodules修改完成...
.\pytorch\third_party\onnx\.gitmodules修改完成...
.\pytorch\third_party\onnx\third_party\pybind11\.gitmodules修改完成...
.\pytorch\third_party\onnx-tensorrt\.gitmodules修改完成...
.\pytorch\third_party\onnx-tensorrt\third_party\onnx\.gitmodules修改完成...
.\pytorch\third_party\onnx-tensorrt\third_party\onnx\third_party\pybind11\.gitmodules修改完成...
.\pytorch\third_party\protobuf\.gitmodules修改完成...
.\pytorch\third_party\pybind11\.gitmodules修改完成...
.\pytorch\third_party\tensorpipe\.gitmodules修改完成...
.\pytorch\third_party\tensorpipe\third_party\pybind11\.gitmodules修改完成...
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Jetson环境安装]]></title>
        <id>https://blog.bangwhe.com/post/jetson-huan-jing-an-zhuang/</id>
        <link href="https://blog.bangwhe.com/post/jetson-huan-jing-an-zhuang/">
        </link>
        <updated>2021-05-22T07:29:29.000Z</updated>
        <summary type="html"><![CDATA[<p>从开始安装到我安装完成（安装好了pytorch、torchvision等hrnet的要求库，并能正常运行），花费了有一天吧。下面我就从Jetson开始介绍并写一下自己环境安装过程中遇到的问题。</p>
<h2 id="jetson">Jetson</h2>
<p>jetson是Nvidia开发的适用于边缘计算的嵌入式设备，它有一个<a href="https://forums.developer.nvidia.com">开发者论坛</a>，我有很多问题都是在上面找到答案的，当然还有csdn上。。。</p>
<p>我这台设备是<a href="https://developer.nvidia.com/embedded/jetson-agx-xavier-developer-kit">jetson agx xavier</a>，它是一个方盒子，并不像其他的jetson设备那样是裸板子。</p>
]]></summary>
        <content type="html"><![CDATA[<p>从开始安装到我安装完成（安装好了pytorch、torchvision等hrnet的要求库，并能正常运行），花费了有一天吧。下面我就从Jetson开始介绍并写一下自己环境安装过程中遇到的问题。</p>
<h2 id="jetson">Jetson</h2>
<p>jetson是Nvidia开发的适用于边缘计算的嵌入式设备，它有一个<a href="https://forums.developer.nvidia.com">开发者论坛</a>，我有很多问题都是在上面找到答案的，当然还有csdn上。。。</p>
<p>我这台设备是<a href="https://developer.nvidia.com/embedded/jetson-agx-xavier-developer-kit">jetson agx xavier</a>，它是一个方盒子，并不像其他的jetson设备那样是裸板子。</p>
<!-- more -->
<h2 id="bug">bug</h2>
<h3 id="外设">外设</h3>
<p>我碰到的第一个问题就是外设不对，这台agx xavier配的是<strong>美国的插座插头</strong>，而不是中国的。排除掉我自己想偷懒的原因，大部分还是这个插头阻止了我在寒假里捣鼓它。所以必须买一个转接器，才能插到国内的插座上，没叫老师给我换主要还是我满口答应下来了。。。</p>
<h3 id="jetson系统">jetson系统</h3>
<p>这台jetson agx xavier自带了Ubuntu 1804 LTSC系统，我本来想在这台机子上安装环境的，这样就不需要刷机了。但是这个jetson系统是基于jetpack 3.3开发的，而jetpack 3.3的介绍是这样的：<code>JetPack 3.3 includes support for the latest L4T BSP software packages for the Jetson TX2, Jetson TX2i, and Jetson TX1 Developer Kits. Automatically flash your Jetson Developer Kit with the latest BSPs (L4T 28.2.1 for Jetson TX2 and TX2i and L4T 28.2 for Jetson TX1) and install the latest software tools required to build and profile for applications for the Jetson Platform. This package contains CUDA toolkit for the host (Ubuntu) and target platform, the latest NVIDIA Developer Tools (Tegra Graphics Debugger 2.5 and NVIDIA System Profiler 4.0), VisionWorks 1.6, cuDNN v7.1.5, Multimedia API v28.2, OpenCV 3.3.1, and TensorRT 4.0 GA.</code>，它适用于TX2，TX2i，TX1等，但是就不适用于agx xavier。不过我想7.1.5的cudnn好像也能用pytorch，但是官方发布的<a href="https://forums.developer.nvidia.com/t/pytorch-for-jetson-version-1-7-0-now-available/72048">pytorch与jetpack版本对应</a>告诉了我，这不可能，必须用jetpack 4.x才能用1.0+的pytorch。所以我最后只能对xavier进行刷机。</p>
<h3 id="刷机">刷机</h3>
<p>xavier刷机其实也有挺多教程的了，我放几个我主要参考的教程：<br>
<a href="https://docs.nvidia.com/sdk-manager/install-with-sdkm-jetson/index.html">官方</a></p>
<p><a href="https://blog.csdn.net/abc13526222160/article/details/106693457">Xavier(arrch64架构)刷机Jetpack4.2</a>：这个我认为是从刷机到环境配置最全的</p>
<p><a href="https://blog.csdn.net/Tosonw/article/details/103990404">Jetson Xavier 刷机Jetpack4.3</a>：这个是救了我命的</p>
<p>其他的刷机教程也可以参考，但是我觉得比较类似，主要是找到适合自己硬件情况的文章。</p>
<h4 id="刷机所需软硬件">刷机所需软硬件</h4>
<p>Ubuntu1804或1604机器，我用的是VMware虚拟机</p>
<p>jetson硬件</p>
<p>电源线</p>
<p>原装USBA to USBC线</p>
<h4 id="刷机过程">刷机过程</h4>
<p>刷机过程就不写了，很多教程都有放具体的图片，我就说说碰到的问题（这部分应该是我安装环境的最耗时的部分，太考验网络环境和人品了）：</p>
<ul>
<li>nvidia开发者账号注册，这个太看网络情况了，建议开代理</li>
<li>usb线的连接方式，正如第三个链接里所说的那样，<strong>USBC要接在电源键附近的接口</strong>，否则host不会将jetson识别为usb设备，而是一台可操作的机器</li>
<li>网上有很多用旧的jetpack直接安装的方法，但是现在都是用sdk manager管理jetson上的sdk了，我个人在没有linux的情况下觉得不太好用。<br>
<img src="https://blog.bangwhe.com/post-images/1621701302346.png" alt="jetson download center里只能用sdk manager对xavier刷机" loading="lazy"></li>
<li>sdk manager的登录，比较考验网络情况，最好开代理，否则要多试几次</li>
<li>Jetson OS Image的下载，这个也比较看网络情况，可能有时候就是网络卡住了，导致下载卡住了，然后整个安装中止</li>
<li>Jetson OS Image中的Drivers for Jetson部分出现的bug：<code>Could not get lock /var/lib/dpkg/lock-frontend</code>，这个是apt-get无法使用导致的，可以看<a href="https://zhuanlan.zhihu.com/p/126538251">这个</a>修复</li>
</ul>
<p>下载、生成、烧录好系统镜像后，那就是安装SDK了。注意：烧录好镜像之后，jetson上就是全新的系统了，必须重新进入设置用户名和密码。SDK安装没啥玄学，基本上就是下载，执行指令，安装。如果不需要SDK，那么就会在jetson上执行最小安装，得到一个空白的Ubuntu 1804系统。如果后续还想要安装SDK，在SDK manager上选定SDK即可，不要选定OS Image。</p>
<h3 id="安装虚拟环境">安装虚拟环境</h3>
<p>安装虚拟环境这一步主要是安装miniforge，miniforge的使用与anaconda基本一致，主要变得可能就是路径上吧。可能还需要换个源，加速。</p>
<h3 id="安装pytorch">安装pytorch</h3>
<p>https://qengineering.eu/install-pytorch-on-jetson-nano.html</p>
<p>最大的bug：<code>import torch</code>后显示<code>Illegal Instruction(Core Dumped)</code>。在<a href="https://forums.developer.nvidia.com/t/illegal-instruction-core-dumped/165488">这里</a>说明了是由于numpy 1.19.5导致的，换成1.19.4就行了。。。</p>
<h3 id="安装torchvision">安装torchvision</h3>
<p>torchvision的安装其实比较简单，主要就是下载torchvision并在本机上编译，不过可能会由于一些库的原因，导致torchvision编译失败。我这里出现的bug是<code>libavformat</code>库好像啥啥啥用不了，所以重新安装了<code>libavformat-dev</code>，对所有出现了的都这样解决了。</p>
<h3 id="安装opencv">安装opencv</h3>
<p>jetpack4.5的SDK安装中的Computer Vision部分就会安装好opencv，所以我只需要把编译完成的so文件移动到我的python路径内就行。可以参考第二个链接，它是重新编译opencv，但是我只需要把opencv的so文件移动过去即可，即<code>sudo cp /usr/local/lib/python3.6/dist-packages/cv2.cpython-36m-aarch64-linux-gnu.so /home/bangwhe/miniforge-pypy3/envs/hrnet/lib/python3.6/site-packages/cv2.so</code></p>
<h3 id="安装dgl">安装dgl</h3>
<p>https://github.com/dmlc/dgl/issues/2424</p>
<p>https://github.com/dmlc/dgl/issues/2661</p>
<p>修复了arm架构bug的dgl库只支持python3.7，但是nvidia只支持了python3.6的torch的whl文件。所以现在的解决方案有三个：</p>
<ul>
<li>编译python 3.7版本的torch，这条可行性应该最大</li>
<li>编译python 3.6版本的dgl，但是不太可行，因为修复了arm架构bug的dgl库不支持python3.6</li>
<li>直接复制dgl源码运行，不知道是否支持CUDA或者CUDNN</li>
</ul>
<p>似乎可行的安装方法：</p>
<ul>
<li><a href="https://forums.developer.nvidia.com/t/install-pytorch-with-python-3-8-on-jetpack-4-4-1/160060">Install PyTorch with Python 3.8 in Jetpack 4.4.1</a>，论坛里这个讨论里有人安装成功了</li>
<li><a href="https://github.com/KumaTea/pytorch-aarch64#cuda--cudnn-support">KumaTea PyTorch-aarch64</a>，github某个用户编译好的针对CPU版本的pytorch，安装命令为<code>pip install torch -f https://torch.maku.ml/whl/stable.html</code>，拥有Nvidia显卡支持的Jetson如果想要使用CUDA和CUDNN加速则必须通过源码编译安装。</li>
<li><code>https://download.pytorch.org/whl/torch_stable.html</code>，这是pytorch官方发布的稳定的pytorch版本，但是上面显示只支持CPU，而不是CUDA，所以如果想要使用显卡加速还是得编译源码。</li>
</ul>
<h2 id="环境安装">环境安装</h2>
<p>这次的环境安装是为了解决<a href="https://forums.developer.nvidia.com/t/compiled-pytorch-error-in-jetson-xavier-agx/178664">这个bug</a></p>
<h3 id="pytorch">pytorch</h3>
<p>pytorch的克隆和编译都比较慢，最后用的是别人编译完成的whl文件。在<a href="https://forums.developer.nvidia.com/t/pytorch-for-jetson-version-1-8-0-now-available/72048/830">这个链接</a>下搜索google基本上都有，我一共下载了两个：<a href="https://forums.developer.nvidia.com/t/pytorch-for-jetson-version-1-8-0-now-available/72048/830">torch-1.8.1a0+56b43f4-cp37-cp37m-linux_aarch64.whl</a>和<a href="https://drive.google.com/file/d/1lMSZu_hARJDpfZuJHc64Hb3OXntlRO--/view?usp=sharing"> torch-1.7.0a0-cp38-cp38-linux_aarch64.whl</a></p>
<p>给出编译好的whl文件的真是大善人~</p>
<h3 id="torchvision">torchvision</h3>
<p>直接安装whl文件，whl文件从<a href="https://github.com/KumaTea/pytorch-aarch64#cuda--cudnn-support">KumaTea PyTorch-aarch64</a>下。（实测不行，因为这些版本似乎是CPU版本，必须用GPU版本的）</p>
<p>必须走编译路线</p>
<h3 id="dgl">dgl</h3>
<p>编译吧，dgl最新的编译失败了，没有生成whl文件，最后用的是编译之后的源码直接放到packages里的方法提供环境依赖。</p>
<h3 id="环境安装结果">环境安装结果</h3>
<p>python：3.7<br>
torch：1.8<br>
torchvision：0.7.0<br>
dgl：0.6<br>
CUDA：10.2.89<br>
cuDNN：8.0.0.180</p>
<p>链接: https://pan.baidu.com/s/1rpiIUR6UA_qzWRPQAa4KmA 提取码: 79qc 复制这段内容后打开百度网盘手机App，操作更方便哦</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[2021-05-20-Papers]]></title>
        <id>https://blog.bangwhe.com/post/2021-05-20-papers/</id>
        <link href="https://blog.bangwhe.com/post/2021-05-20-papers/">
        </link>
        <updated>2021-05-20T02:49:37.000Z</updated>
        <content type="html"><![CDATA[<p><a href="http://arxiv.org/abs/2105.09008">A Novel lightweight Convolutional Neural Network, ExquisiteNetV2.</a>主要就是把很多计算量大的卷积核改成了depth-wise卷积和池化、BN等计算量和参数量都比较小的模块。主要是作者居然找了十几个不知名的数据集，离谱，你怎么不用CIFAR10、CIFAR100、ImageNet呢。</p>
]]></content>
    </entry>
</feed>